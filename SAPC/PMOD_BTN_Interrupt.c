/**
 * @file PMOD_BTN_Interrupt.c
 *
 * @brief Source file for the PMOD_BTN_Interrupt driver.
 *
 * This file contains the function definitions for the PMOD_BTN_Interrupt driver.
 * It interfaces with the PMOD BTN module. The following pin is used:
 *  - PMOD BTN0 (PA2)
 *  - PMOD BTN1 (PA3)
 *  - PMOD BTN2 (PA4)
 *  - PMOD BTN3 (PA5)
 *
 * It configures the pins to trigger interrupts on rising edges. The PMOD BTN
 * push buttons operate in an active high configuration.
 *
 * @author Aaron Nanas
 * @editor Cameron Williams
 */


#include "PMOD_BTN_Interrupt.h"

// Declare pointer to the user-defined task
void (*PMOD_BTN_Task)(uint8_t pmod_btn_state);

void PMOD_BTN_Interrupt_Init(void(*task)(uint8_t))
{
	// Store the user-defined task function for use during interrupt handling
    PMOD_BTN_Task = task;

    // Enable the clock to Port A by setting the R3 bit (Bit 0) in the RCCCGPIO register
    SYSCTL->RCGCGPIO |= 0x01;

    // Configure pins PA5-2 as input
    GPIOA->DIR &= ~0x3C;

    // Configure pins PA5-2 pins to function as GPIO pins
    GPIOA->AFSEL &= ~0x3C;

    // Enable digital functionality for pins PA5-2 
    GPIOA->DEN |= 0x3C;

    // Enable the weak pull-down resistor for pins PA5-2 
    GPIOA->PDR |= 0x3C;

    // Configure pins PA5-2 to detect edges
    GPIOA->IS &= ~0x3C;

    // Allow GPIOIEV register to handle interrupt generation and determine which edge to check for pins PA5-2
    GPIOA->IBE &= ~0x3C;

    // Configure pins PA5-2 to detect rising edges
    // Rising edges on corresponding pins will trigger interrupts  
    GPIOA->IEV |= 0x3C;

    // Clear any existing interrupt flags on pins PA5-2
    GPIOA->ICR |= 0x3C;

    // Allow the interrupts that are generated by pins PA5-2 to be sent to the interrupt controller
		GPIOA->IM |= 0x3C;
		
		// Clear the INTD field (Bits 7 to 5) of the IPR[0] register (PRIO)
		NVIC->IPR[0] &= ~0xE0;
		
		// Set the priority level of the interrupts to 3. Port A has an Interrupt
		// Request (IRQ) number of 3
		NVIC->IPR[0] |= (3 << 5);
		
		// Enable IRQ 3 for GPIO Port A by setting Bit 0 in the ISER[0] register
		NVIC->ISER[0] |= (1 << 0);
}

uint8_t PMOD_BTN_Read(void)
{
	// Declare a local variable to store the status of the PMOD BTN push buttons
	// Then, read the DATA register for Port A
	// A "0x04" bit mask is used to only capture the PA2 to PA5 pins used the PMOD BTN module
	uint8_t pmod_btn_state = GPIOA->DATA & 0x3C;
	
	// Return the status of the PMOD BTN module
	return pmod_btn_state;
}

void GPIOA_Handler(void)
{
	if (GPIOA->MIS & 0x3C)
	{
		// Read the status of the PA2 to PA5 pins
		uint8_t pmod_btn_state = GPIOA->DATA & 0x3C;
		
		// Execute the user-defined function and pass the status of the PA3 and PA2 pins
		(*PMOD_BTN_Task)(pmod_btn_state);
		
		// Acknowledge the interrupt from either the PA3 or the PA2 pin and clear it
		GPIOA->ICR |= 0x3C;
	}
}
